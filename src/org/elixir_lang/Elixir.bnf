{
  parserClass="org.elixir_lang.parser.ElixirParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  // direct children of matchedExpression
  extends("matched(AccessExpression|.*Operation|((((At)?Unq)|Q)ualified(No)?(Argument|Parenthese)s|Dot)Call|Qualified(Alias|MultipleAliases))")=matchedExpression
  // direct children of unmatchedExpression
  extends("unmatched(AccessExpression|.*Operation|((((At)?Unq)|Q)ualified(No)?(Argument|Parenthese)s|Dot)Call|Qualified(Alias|MultipleAliases))")=unmatchedExpression

  // name identifier owner calls - no argument calls are included because in a pipeline they can have effective arguments
  elementTypeFactory("((un)?matched((((At)?Unq)|Q)ualified(No)?(Argument|Parenthese)s|Dot)|unqualifiedNoParenthesesManyArguments)Call")="org.elixir_lang.ElementTypeFactory.factory"
  methods(           "((un)?matched((At)?Unqualified(No)?(Argument|Parenthese)s|Dot)|unqualifiedNoParenthesesManyArguments)Call")=[
    canonicalName
    canonicalNameSet
    functionName
    functionNameElement
    getDoBlock
    hasDoBlockOrKeyword
    getName
    getNameIdentifier
    getPresentation
    getReference
    getStub
    getUseScope
    isCalling
    isCallingMacro
    implementedProtocolName
    moduleName
    primaryArguments
    primaryArity
    processDeclarations
    quote
    resolvedFinalArity
    resolvedFinalArityInterval
    resolvedModuleName
    resolvedPrimaryArity
    resolvedSecondaryArity
    secondaryArguments
    secondaryArity
    setName
  ]

  // qualified calls that need to implement #qualifier()
  methods("(un)?matchedQualified(No)?(Argument|Parenthese)sCall")=[
    canonicalName
    canonicalNameSet
    functionName
    functionNameElement
    getDoBlock
    hasDoBlockOrKeyword
    getName
    getNameIdentifier
    getPresentation
    getReference
    getStub
    getUseScope
    implementedProtocolName
    isCalling
    isCallingMacro
    moduleName
    primaryArguments
    primaryArity
    processDeclarations
    qualifier
    quote
    resolvedFinalArity
    resolvedFinalArityInterval
    resolvedModuleName
    resolvedPrimaryArity
    resolvedSecondaryArity
    secondaryArguments
    secondaryArity
    setName
  ]

  // in operations that works as calls
  implements("(un)?matchedInOperation")=[
    "org.elixir_lang.psi.call.Call"
    "org.elixir_lang.psi.operation.In"
  ]
  // methods set by infix operations below

  // `not in` operations that works as calls
  implements("(un)?matchedNotInOperation")=[
    "org.elixir_lang.psi.call.Call"
    "org.elixir_lang.psi.operation.NotIn"
  ]
  methods("(un)?matchedNotInOperation")=[
    functionName
    functionNameElement
    getDoBlock
    getName
    getNameIdentifier
    hasDoBlockOrKeyword
    isCalling
    isCallingMacro
    leftOperand
    moduleName
    operator
    primaryArguments
    primaryArity
    processDeclarations
    quote
    resolvedFinalArity
    resolvedFinalArityInterval
    resolvedModuleName
    resolvedPrimaryArity
    resolvedSecondaryArity
    rightOperand
    secondaryArguments
    secondaryArity
    setName
  ]

  /* infix operations that work as name identifier owner calls - specifically support getNameIdentifier so they can
     return their operator, so it is easy to use a different operator when making customer operators like in Bitwise or
     the free arrow operators */
  implements(        "(un)?matched(Comparison|Relational)Operation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Infix"
  ]
  methods(           "(un)?matched(Addition|And|Arrow|Comparison|In|InMatch|Match|Multiplication|Or|Pipe|Power|Relational|Three|Two|Type|When)Operation")=[
    functionName
    functionNameElement
    getDoBlock
    getName
    getNameIdentifier
    hasDoBlockOrKeyword
    isCalling
    isCallingMacro
    leftOperand
    moduleName
    operator
    primaryArguments
    primaryArity
    processDeclarations
    quote
    resolvedFinalArity
    resolvedFinalArityInterval
    resolvedModuleName
    resolvedPrimaryArity
    resolvedSecondaryArity
    rightOperand
    secondaryArguments
    secondaryArity
    setName
  ]

  implements("(un)?matchedAdditionOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Addition"
  ]
  // methods set by infix operations above

  implements("(un)?matchedAndOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.And"
  ]
  // methods set by infix operations above

  implements("(un)?matchedArrowOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Arrow"
  ]

  implements("(un)?matchedInMatchOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.InMatch"
  ]
  // methods set by infix operations above

  implements("(un)?matchedMatchOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Match"
  ]
  // methods set by infix operations above

  implements("(un)?matchedMultiplicationOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Multiplication"
  ]
  // methods set by infix operations above

  implements("(un)?matchedPowerOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Power"
  ]
  // methods set by infix operations above

  implements("(un)?matchedOrOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Or"
  ]
  // methods set by infix operations above

  implements("(un)?matchedPipeOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Pipe"
  ]
  // methods set by infix operations above

  implements("(un)?matchedThreeOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Three"
  ]
  // methods set by infix operations above

  implements("(un)?matchedTwoOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Two"
  ]
  // methods set by infix operations above

  implements("(un)?matchedTypeOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Type"
  ]
  // methods set by infix operations above

  implements("(un)?matchedWhenOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.When"
  ]
  // methods set by infix operations above

  /*
   * Prefix operations
   *
   * Have names (their operators), but aren't stubbed because they don't define structures.
   */
  implements(        "(at|capture|unary)NumericOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Prefix"
  ]
  methods(           "((at|capture|unary)Numeric|(un)?matched(UnaryNonNumeric|Unary))Operation")=[
    functionName
    functionNameElement
    getDoBlock
    getName
    getNameIdentifier
    hasDoBlockOrKeyword
    isCalling
    isCallingMacro
    moduleName
    operand
    operator
    primaryArguments
    primaryArity
    quote
    secondaryArguments
    secondaryArity
    resolvedFinalArity
    resolvedFinalArityInterval
    resolvedModuleName
    resolvedPrimaryArity
    resolvedSecondaryArity
    setName
  ]

  // at operations
  implements("(un)?matchedAtOperation")=[
    "org.elixir_lang.psi.AtOperation"
  ]
  methods("(un)?matchedAtOperation")=[
    getReference
    moduleAttributeName
    operand
    operator
    quote
  ]

  // captureNonNumeric operations
  implements(        "(un)?matched.*CaptureNonNumericOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.capture.NonNumeric"
  ]
  methods(           "(un)?matched.*CaptureNonNumericOperation")=[
    functionName
    functionNameElement
    getDoBlock
    getName
    getNameIdentifier
    getReference
    hasDoBlockOrKeyword
    isCalling
    isCallingMacro
    moduleName
    operand
    operator
    primaryArguments
    primaryArity
    quote
    secondaryArguments
    secondaryArity
    resolvedFinalArity
    resolvedFinalArityInterval
    resolvedModuleName
    resolvedPrimaryArity
    resolvedSecondaryArity
    setName
  ]

  // unaryNonNumeric operations
  implements("(un)?matchedUnaryOperation")=[
    "org.elixir_lang.psi.UnaryOperation"
  ]
  // method set by prefix operations above

  // QualifiedBracketOperation
  implements("(un)?matchedQualifiedBracketOperation")=[
    "org.elixir_lang.psi.QualifiedBracketOperation"
  ]
  methods(   "(un)?matchedQualifiedBracketOperation")=[
    qualifier
    quote
  ]

  // QualifiedMultipleAliases
  implements("(un)?matchedQualifiedMultipleAliases")=[
    "org.elixir_lang.psi.QualifiedMultipleAliases"
  ]
  methods(   "(un)?matchedQualifiedMultipleAliases")=[
    quote
  ]

  // Heredoc
  methods("(charList|string)Heredoc")=[
    addEscapedCharacterCodePoints
    addEscapedEOL
    addFragmentCodePoints
    addHexadecimalEscapeSequenceCodePoints
    getFragmentType
    getHeredocLineList
    quote
    quoteBinary
    quoteEmpty
    quoteInterpolation
    quoteLiteral
  ]

  // Quote
  methods("(charList|string)Line") = [
    addEscapedCharacterCodePoints
    addEscapedEOL
    addFragmentCodePoints
    addHexadecimalEscapeSequenceCodePoints
    getBody
    getFragmentType
    quote
    quoteAsAtom
    quoteBinary
    quoteEmpty
    quoteInterpolation
    quoteLiteral
  ]

  // Sigil Heredoc
  methods("(interpolated|literal)((CharList|String)Sigil|Regex|Sigil|Words)Heredoc") = [
    addEscapedCharacterCodePoints
    addEscapedEOL
    addFragmentCodePoints
    addHexadecimalEscapeSequenceCodePoints
    getFragmentType
    getHeredocLineList
    indentation
    quote
    quoteBinary
    quoteEmpty
    quoteInterpolation
    quoteLiteral
    sigilDelimiter
    sigilName
  ]

  // Sigil Line
  methods("(interpolated|literal)((CharList|String)Sigil|Regex|Sigil|Words)Line") = [
    addEscapedCharacterCodePoints
    addEscapedEOL
    addFragmentCodePoints
    addHexadecimalEscapeSequenceCodePoints
    getBody
    getFragmentType
    indentation
    quote
    quoteBinary
    quoteEmpty
    quoteInterpolation
    quoteLiteral
    sigilDelimiter
    sigilName
    terminator
  ]

  psiClassPrefix="Elixir"
  psiImplClassSuffix="Impl"
  psiPackage="org.elixir_lang.psi"
  psiImplPackage="org.elixir_lang.psi.impl"
  psiImplUtilClass="org.elixir_lang.psi.impl.ElixirPsiImplUtil"

  elementTypeHolderClass="org.elixir_lang.psi.ElixirTypes"
  elementTypeClass="org.elixir_lang.psi.ElixirElementType"
  tokenTypeClass="org.elixir_lang.psi.ElixirTokenType"

  tokens = [
    ADDITION_OPERATOR = "+"
    AFTER = "after"
    ALIAS_TOKEN = "Alias"
    AND_SYMBOL_OPERATOR = "&&&, &&"
    AND_WORD_OPERATOR = "`and`"
    ARROW_OPERATOR = "<<<, <<~, <|>, <~>, >>>, ~>>, <~, |>, ~>"
    ASSOCIATION_OPERATOR = "=>"
    ATOM_FRAGMENT = "A-Z, a-z, _, @, 0-9. ?, !"
    AT_OPERATOR = "@"
    BASE_WHOLE_NUMBER_PREFIX = "0"
    BINARY_WHOLE_NUMBER_BASE = "b"
    BIT_STRING_OPERATOR = "<<>>"
    CALL = "<zero-width-call>"
    CAPTURE_OPERATOR = "&"
    CATCH = "catch"
    CHAR_LIST_FRAGMENT = "Char List Fragment"
    CHAR_LIST_HEREDOC_PROMOTER = "Char List Heredoc Promoter (''')"
    CHAR_LIST_HEREDOC_TERMINATOR = "Char List Heredoc Terminator (''')"
    CHAR_LIST_PROMOTER = "Char List Promoter (')"
    CHAR_LIST_SIGIL_HEREDOC_PROMOTER = "Char List Sigil Heredoc Promoter (\"\"\", ''')"
    CHAR_LIST_SIGIL_HEREDOC_TERMINATOR = "Char List Sigil Heredoc Terminator (\"\"\", ''')"
    CHAR_LIST_SIGIL_PROMOTER = "Char List Sigil Promoter ({, [, <, \", /, (, |, ')"
    CHAR_LIST_SIGIL_TERMINATOR = "Char List Sigil Terminator (}, ], >, \", /, ), |, ')"
    CHAR_LIST_TERMINATOR = "Char List Terminator (')"
    CHAR_TOKENIZER = "?"
    CLOSING_BIT = ">>"
    CLOSING_BRACKET = "]"
    CLOSING_CURLY = "}"
    // TODO remove once CLOSING_PARENTHESIS is used in emptyParentheses rule
    CLOSING_PARENTHESIS = ")"
    COLON = ":"
    COMMA = ","
    COMMENT = "#"
    COMPARISON_OPERATOR = "!==, ===, !=, ==, =~"
    DECIMAL_MARK = "Decimal Mark (.)"
    DIVISION_OPERATOR = "/"
    DO = "do"
    DOT_OPERATOR = "."
    EEX_CLOSING = "%>"
    EEX_COMMENT = "EEx Comment"
    EEX_COMMENT_MARKER = "EEx Comment Marker (#)"
    EEX_DATA = "EEx Data"
    EEX_EMPTY_MARKER = "EEx Empty Marker"
    EEX_EQUALS_MARKER = "EEx Equals Marker (=)"
    EEX_ESCAPED_OPENING = "<%%"
    EEX_FORWARD_SLASH_MARKER = "EEx Forward Slash Marker (/)"
    EEX_OPENING = "<%"
    EEX_PIPE_MARKER = "EEx Pipe Marker (|)"
    ELSE = "else"
    EOL = "\\n, \\r\\n"
    END = "end"
    ESCAPE = "\\"
    ESCAPED_CHARACTER_TOKEN = "\\<character>, \\x{<hexadecimal-digit>}, \\x<hexadecimal-digit>, \\\\n, \\\\r\\n"
    EXPONENT_MARK = "E, e"
    FALSE = "false"
    FN = "fn"
    HEREDOC_LINE_WHITE_SPACE_TOKEN = "Whitespace at beginning of line of heredoc"
    HEREDOC_PREFIX_WHITE_SPACE = "Whitespace at beginning of last line of heredoc before terminator"
    HEXADECIMAL_WHOLE_NUMBER_BASE = "x"
    IDENTIFIER_TOKEN = "identifier"
    INTERPOLATING_CHAR_LIST_SIGIL_NAME = "c"
    INTERPOLATING_REGEX_SIGIL_NAME = "r"
    INTERPOLATING_SIGIL_NAME = "a-b, d-q, t-v, x-z"
    INTERPOLATING_STRING_SIGIL_NAME = "s"
    INTERPOLATING_WORDS_SIGIL_NAME = "w"
    // Can't be just "}", because that's used for the more general CLOSING_CURLY
    INTERPOLATION_END = "Interpolation End (})"
    // Human-readable "Interpolation Start" to match format of INTERPOLATION_END
    INTERPOLATION_START = "Interpolation Start (#{)"
    INVALID_BINARY_DIGITS = "A-Z, a-z, 2-9"
    INVALID_DECIMAL_DIGITS = "A-Z, a-z"
    INVALID_HEXADECIMAL_DIGITS = "G-Z, g-z"
    INVALID_OCTAL_DIGITS = "A-Z, a-z, 8-9"
    INVALID_UNKNOWN_BASE_DIGITS = "A-Z, a-z, 0-9"
    IN_MATCH_OPERATOR = "<-, \\\\"
    IN_OPERATOR = "in"
    KEYWORD_PAIR_COLON = "Keyword Pair Colon (:)"
    LITERAL_CHAR_LIST_SIGIL_NAME = "C"
    LITERAL_REGEX_SIGIL_NAME = "R"
    LITERAL_SIGIL_NAME = "A-B, D-Q, T-V, X-Z"
    LITERAL_STRING_SIGIL_NAME = "S"
    LITERAL_WORDS_SIGIL_NAME = "W"
    MAP_OPERATOR = "%{}"
    MATCH_OPERATOR = "="
    MINUS_OPERATOR = "-"
    MULTIPLICATION_OPERATOR = "*"
    NEGATE_OPERATOR = "-"
    NIL = "nil"
    NOT_OPERATOR = "not"
    NUMBER_SEPARATOR = "_"
    NUMBER_OR_BADARITH_OPERATOR = "+"
    OBSOLETE_BINARY_WHOLE_NUMBER_BASE = "B"
    OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE = "X"
    OCTAL_WHOLE_NUMBER_BASE = "o"
    OPENING_BIT = "<<"
    OPENING_BRACKET = "["
    OPENING_CURLY = "{"
    OPENING_PARENTHESIS = "("
    OR_SYMBOL_OPERATOR = "|||, ||"
    OR_WORD_OPERATOR = "`or`"
    PIPE_OPERATOR = "|"
    PLUS_OPERATOR = "+"
    POWER_OPERATOR = "**"
    RANGE_OPERATOR = ".."
    REGEX_FRAGMENT = "Regex Fragment"
    REGEX_HEREDOC_PROMOTER = "Regex Heredoc Promoter (\"\"\", ''')"
    REGEX_HEREDOC_TERMINATOR = "Regex Heredoc Terminator (\"\"\", ''')"
    REGEX_PROMOTER = "Regex Promoter ({, [, <, \", /, (, |, ')"
    REGEX_TERMINATOR = "Regex Terminator ({, [, <, \", /, (, |, ')"
    RELATIONAL_OPERATOR = "<, <=, >=, >"
    RESCUE = "rescue"
    // TOO remove once SEMICOLON is used in endOfExpression rule
    SEMICOLON = ";"
    SIGIL_FRAGMENT = "Sigil Fragment"
    SIGIL_HEREDOC_PROMOTER = "Sigil Heredoc Promoter (\"\"\", ''')"
    SIGIL_HEREDOC_TERMINATOR = "Sigil Heredoc Terminator (\"\"\", ''')"
    SIGIL_MODIFIER = "Sigil Modifier (A-Z, a-z)"
    SIGIL_PROMOTER = "Sigil Promoter ({, [, <, \", /, (, |, ')"
    SIGIL_TERMINATOR = "Sigil Terminator ({, [, <, \", /, (, |, ')"
    SIGN_OPERATOR = "Sign Operator (+, -)"
    STAB_OPERATOR = "->"
    STRING_FRAGMENT = "String Fragment"
    STRING_HEREDOC_PROMOTER = "String Heredoc Promoter (\"\"\")"
    STRING_HEREDOC_TERMINATOR = "String Heredoc Terminator (\"\"\")"
    STRING_PROMOTER = "String Promoter (\")"
    STRING_SIGIL_HEREDOC_PROMOTER = "String Sigil Heredoc Promoter (\"\"\", ''')"
    STRING_SIGIL_HEREDOC_TERMINATOR = "String Sigil Heredoc Terminator (\"\"\", ''')"
    STRING_SIGIL_PROMOTER = "String Sigil Promoter ({, [, <, \", /, (, |, ')"
    STRING_SIGIL_TERMINATOR = "String Sigil Terminator ({, [, <, \", /, (, |, ')"
    STRING_TERMINATOR = "String Terminator (\")"
    // TODO remove once containers are available for `{}` after alias for empty structs
    STRUCT_OPERATOR = "%"
    SUBTRACTION_OPERATOR = "-"
    TILDE = "~"
    TRUE = "true"
    TUPLE_OPERATOR = "{}"
    TWO_OPERATOR = "++, --, <>"
    // https://github.com/elixir-lang/elixir/commit/3487d00ddb5e90c7cf0e65d03717903b9b27eafd
    THREE_OPERATOR = "^^^"
    TYPE_OPERATOR = "::"
    UNARY_OPERATOR = "~~~, !, ^"
    UNICODE_ESCAPE_CHARACTER = "u"
    UNKNOWN_WHOLE_NUMBER_BASE = "A-Z, a, c-n, p-w, z"
    VALID_BINARY_DIGITS = "0-1"
    VALID_DECIMAL_DIGITS = "0-9"
    VALID_HEXADECIMAL_DIGITS = "A-F, a-f, 0-9"
    VALID_OCTAL_DIGITS = "0-7"
    WHEN_OPERATOR = "when"
    WORDS_FRAGMENT = "Words Fragment"
    WORDS_HEREDOC_PROMOTER = "Words Heredoc Promoter (\"\"\", ''')"
    WORDS_HEREDOC_TERMINATOR = "Words Heredoc Terminator (\"\"\", ''')"
    WORDS_PROMOTER = "Words Promoter ({, [, <, \", /, (, |, ')"
    WORDS_TERMINATOR = "Words Terminator ({, [, <, \", /, (, |, ')"
  ]
}

// `elixirFile` has more error recovery, so it'll match almost anything, so it needs to be after `eex`
private eexOrElixirFile ::= eex | elixirFile

// expressionList is optional to handle code-less file that contains only EOL between blank lines and order comment
// lines
private elixirFile ::= endOfExpressionMaybe (expressionList endOfExpressionMaybe)?

/*
 *
 *
 * Expression List
 *
 *
 */

private eolStar ::= EOL*
// Must have at least one EOL or SEMICOLON, but at most one SEMICOLON
endOfExpression ::= SEMICOLON | EOL+ { implements = "org.elixir_lang.psi.Unquoted" }
private endOfExpressionMaybe ::= endOfExpression?

/*
 *
 * Expression
 *
 */

private expression ::= emptyParentheses |
                       unmatchedExpression |
                       unqualifiedNoParenthesesManyArgumentsCall
                       { recoverWhile = expressionRecoverWhile }
// EOL and SEMICOLON for endOfExpression
/* INTERPOLATION_END because interpolation(elixirFile(expression)) needs expression to stop of on INTERPOLATION_END for
   interpolation */
// END for stabBody's usage of expression
// CLOSING_* because they are endings to subexpressions
// STAB_OPERATOR because it ends when clause for no parentheses stab guard clauses
// blockIdentifier for one-liner blockItems where there isn't a newline between block expressions and following blockIdentifier.
private expressionRecoverUntil ::= EOL | CLOSING_BIT | CLOSING_BRACKET | CLOSING_CURLY | CLOSING_PARENTHESIS | COMMA | INTERPOLATION_END | SEMICOLON | STAB_OPERATOR | END | blockIdentifier | EEX_CLOSING
private expressionRecoverWhile ::= !expressionRecoverUntil

private expressionList ::= expression (endOfExpression expression)*

/*
 *
 *
 * Function Calls
 *
 *
 */

/*
 *
 * No Parentheses
 *
 */

/*
 * Many Arguments
 */

/* Have to prevent matchedExpression that is actually a keywordKey from being parsed as just a matchedExpression or
   callArgumentsNoParenthesesCommaExpression COMMA EOL* callArgumentsNoParenthesesKeywords will never match. */
private noParenthesesExpression ::= emptyParentheses |
                                    /* Must be before matchedExpression because noParenthesesExpression is
                                       `matchedExpressionDotIdentifier callArgumentsNoParenthesesManyStrict` which is
                                       longer than `matchedExpressionDotIdentifier` in matchedExpression. */
                                    /* This will be marked as an error by
                                       {@link org.elixir_lang.inspection.NoParenthesesManyStrict} */
                                    noParenthesesManyStrictNoParenthesesExpression |
                                    matchedExpression
/* Special class for wrapping noParenthesesCall so that
   {@link: org.elixir_lang.inspection.NoParenthesesManyStrict} can just search for
   ElixirNoParenthesesManyStrictNoParenthesesExpression isn't of having to differentiate between valid and invalid
   ElixirNoParenthesesCall. */
noParenthesesManyStrictNoParenthesesExpression ::= unqualifiedNoParenthesesManyArgumentsCall
                                                   { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
/* Special class for wrapping rules so that
   {@link: org.elixir_lang.inspection.NoParenthesesStrict} can just search for
   ElixirNoParenthesesStrict instead of having to differentiate between valid and invalid
   rule classes. */
noParenthesesStrict ::= emptyParentheses |
                        OPENING_PARENTHESIS (
                                             noParenthesesKeywords |
                                             noParenthesesManyArguments
                                            ) CLOSING_PARENTHESIS
                        {
                          implements = [
                            "org.elixir_lang.psi.Arguments"
                            "org.elixir_lang.psi.QuotableArguments"
                          ]
                          methods = [
                            arguments
                            quoteArguments
                          ]
                        }

/* 1. (positional, keywords)
   2. (positional, positional)
   3. (positional, positional, keywords) */
private noParenthesesManyArguments ::= matchedExpression infixComma noParenthesesKeywords |
                                       matchedExpression (infixComma noParenthesesExpression)+ (infixComma noParenthesesKeywords)?
private noParenthesesManyArgumentsStrict ::= noParenthesesManyArguments |
                                             noParenthesesStrict

// A rule instead of a token so that there is a PsiElement to return from getNameIdentifier
identifier ::= IDENTIFIER_TOKEN
               {
                 implements = "org.elixir_lang.psi.Quotable"
                 methods = [
                   getPresentation
                   getReference
                   quote
                 ]
               }

private notKeywordPairColon ::= !KEYWORD_PAIR_COLON
// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L124-L125
unqualifiedNoParenthesesManyArgumentsCall ::= identifier notKeywordPairColon
                                              noParenthesesManyArgumentsStrict
                                              {
                                                implements = [
                                                  // MUST be first so visitElement is used in ElixirVisitor
                                                  "com.intellij.psi.PsiElement"
                                                  "org.elixir_lang.psi.call.StubBased<org.elixir_lang.psi.stub.UnqualifiedNoParenthesesManyArgumentsCall>"
                                                  "org.elixir_lang.psi.call.arguments.star.NoParentheses"
                                                  "org.elixir_lang.psi.qualification.Unqualified"
                                                  "org.elixir_lang.psi.Quotable"
                                                ]
                                                mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnqualifiedNoParenthesesManyArgumentsCall>"
                                                stubClass = "org.elixir_lang.psi.stub.UnqualifiedNoParenthesesManyArgumentsCall"
                                              }

/*
 * 1+ Arguments
 */

noParenthesesKeywords ::= noParenthesesKeywordPair (infixComma noParenthesesKeywordPair)*
                          {
                            implements = "org.elixir_lang.psi.QuotableKeywordList"
                            methods = [
                              quotableKeywordPairList
                              quote
                            ]
                          }
noParenthesesKeywordPair ::= keywordKeyColon noParenthesesExpression
                             {
                               implements = "org.elixir_lang.psi.QuotableKeywordPair"
                               methods = [
                                 getKeywordKey
                                 getKeywordValue
                                 quote
                               ]
                             }

/*
 * 0 Arguments
 */

variable ::= IDENTIFIER_TOKEN notKeywordPairColon
             {
               implements = [
                 "org.elixir_lang.psi.NamedElement"
                 "org.elixir_lang.psi.Quotable"
               ]
               methods = [
                 getName
                 getNameIdentifier
                 quote
                 setName
               ]
             }

/*
 *
 *
 * Heredoc
 *
 *
 */

heredocLinePrefix ::= HEREDOC_LINE_WHITE_SPACE_TOKEN? { methods = [excessWhitespace] }
heredocPrefix ::= HEREDOC_PREFIX_WHITE_SPACE?

/*
 *
 * Quote Heredocs
 *
 */

/*
 * CharList Heredoc
 */

charListHeredoc ::= CHAR_LIST_HEREDOC_PROMOTER EOL
                    charListHeredocLine*
                    heredocPrefix CHAR_LIST_HEREDOC_TERMINATOR
                    {
                      implements = [
                        "org.elixir_lang.psi.Heredoc"
                        "org.elixir_lang.psi.InterpolatedCharList"
                        "org.elixir_lang.psi.Quote"
                      ]
                      pin = CHAR_LIST_HEREDOC_PROMOTER
                    }
// EOL is optional because when last line EOL is escaped (See https://github.com/KronicDeth/intellij-elixir/issues/1843)
charListHeredocLine ::= heredocLinePrefix charListHeredocLineBody heredocLineEnd
                        {
                          implements = [
                            "org.elixir_lang.psi.HeredocLine"
                          ]
                          methods = [
                            getBody
                            quote
                          ]
                        }
charListHeredocLineBody ::= (interpolation | CHAR_LIST_FRAGMENT | heredocEscapeSequence)*
                            { implements = "org.elixir_lang.psi.Body" }

/*
 * String Heredoc
 */

stringHeredoc ::= STRING_HEREDOC_PROMOTER EOL
                  stringHeredocLine*
                  heredocPrefix STRING_HEREDOC_TERMINATOR
                  {
                    implements = [
                      "org.elixir_lang.psi.Heredoc"
                      "org.elixir_lang.psi.InterpolatedString"
                    ]
                    pin = STRING_HEREDOC_PROMOTER
                  }
// EOL is optional because when last line EOL is escaped (See https://github.com/KronicDeth/intellij-elixir/issues/1843)
stringHeredocLine ::= heredocLinePrefix stringHeredocLineBody heredocLineEnd
                      {
                        implements = [
                          "org.elixir_lang.psi.HeredocLine"
                        ]
                        methods = [
                          getBody
                          quote
                        ]
                      }
stringHeredocLineBody ::= (interpolation | STRING_FRAGMENT | heredocEscapeSequence)*
                          { implements = "org.elixir_lang.psi.Body" }

/*
 *
 * Interpolated Sigil Heredocs
 *
 */

sigilModifiers ::= SIGIL_MODIFIER* { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

interpolatedCharListSigilHeredoc ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                     interpolatedCharListHeredocLine*
                                     heredocPrefix CHAR_LIST_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                     {
                                       implements = [
                                         "org.elixir_lang.psi.CharListFragmented"
                                         "org.elixir_lang.psi.InterpolatedCharListHeredocLined"
                                         "org.elixir_lang.psi.InterpolatedSigilHeredoc"
                                       ]
                                       pin = CHAR_LIST_SIGIL_HEREDOC_PROMOTER
                                     }
interpolatedCharListHeredocLine ::= heredocLinePrefix interpolatedCharListHeredocLineBody heredocLineEnd
                                    {
                                      implements = [
                                        "org.elixir_lang.psi.HeredocLine"
                                      ]
                                      methods = [
                                        getBody
                                        quote
                                      ]
                                    }
interpolatedCharListHeredocLineBody ::= (interpolation | CHAR_LIST_FRAGMENT | sigilHeredocEscapeSequence)*
                                        { implements = "org.elixir_lang.psi.Body" }

interpolatedRegexHeredoc ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                             interpolatedRegexHeredocLine*
                             heredocPrefix REGEX_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.RegexFragmented"
                                 "org.elixir_lang.psi.InterpolatedSigilHeredoc"
                               ]
                               pin = REGEX_HEREDOC_PROMOTER
                             }
interpolatedRegexHeredocLine ::= heredocLinePrefix interpolatedRegexHeredocLineBody heredocLineEnd
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedRegexHeredocLineBody ::= (interpolation | REGEX_FRAGMENT | sigilHeredocEscapeSequence)*
                          { implements = "org.elixir_lang.psi.Body" }

interpolatedSigilHeredoc ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                             interpolatedSigilHeredocLine*
                             heredocPrefix SIGIL_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.InterpolatedSigilHeredoc"
                                 "org.elixir_lang.psi.SigilFragmented"
                               ]
                               pin = SIGIL_HEREDOC_PROMOTER
                             }
interpolatedSigilHeredocLine ::= heredocLinePrefix interpolatedSigilHeredocLineBody heredocLineEnd
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedSigilHeredocLineBody ::= (interpolation | SIGIL_FRAGMENT | sigilHeredocEscapeSequence)*
                                     { implements = "org.elixir_lang.psi.Body" }

interpolatedStringSigilHeredoc ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                                   interpolatedStringHeredocLine*
                                   heredocPrefix STRING_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                   {
                                     implements = [
                                       "org.elixir_lang.psi.StringFragmented"
                                       "org.elixir_lang.psi.InterpolatedSigilHeredoc"
                                       "org.elixir_lang.psi.InterpolatedStringHeredocLined"
                                     ]
                                     pin = STRING_SIGIL_HEREDOC_PROMOTER
                                   }
interpolatedStringHeredocLine ::= heredocLinePrefix interpolatedStringHeredocLineBody heredocLineEnd
                                  {
                                    implements = [
                                      "org.elixir_lang.psi.HeredocLine"
                                    ]
                                    methods = [
                                      getBody
                                      quote
                                    ]
                                  }
interpolatedStringHeredocLineBody ::= (interpolation | STRING_FRAGMENT | sigilHeredocEscapeSequence)*
                                      { implements = "org.elixir_lang.psi.Body" }

interpolatedWordsHeredoc ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                             interpolatedWordsHeredocLine*
                             heredocPrefix WORDS_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.WordsFragmented"
                                 "org.elixir_lang.psi.InterpolatedSigilHeredoc"
                               ]
                               pin = WORDS_HEREDOC_PROMOTER
                             }
// EOL is optional because when last line EOL is escaped (See https://github.com/KronicDeth/intellij-elixir/issues/1843)
interpolatedWordsHeredocLine ::= heredocLinePrefix interpolatedWordsHeredocLineBody heredocLineEnd
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedWordsHeredocLineBody ::= (interpolation | WORDS_FRAGMENT | sigilHeredocEscapeSequence)*
                                     { implements = "org.elixir_lang.psi.Body" }

/*
 * Literal Sigil Heredocs
 */

literalCharListSigilHeredoc ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                literalCharListHeredocLine*
                                heredocPrefix CHAR_LIST_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                {
                                  implements = [
                                    "org.elixir_lang.psi.CharListFragmented"
                                    "org.elixir_lang.psi.LiteralSigilHeredoc"
                                  ]
                                  pin = CHAR_LIST_SIGIL_HEREDOC_PROMOTER
                                }
// EOL is optional because when last line EOL is escaped (See https://github.com/KronicDeth/intellij-elixir/issues/1843)
literalCharListHeredocLine ::= heredocLinePrefix literalCharListHeredocLineBody heredocLineEnd
                               {
                                 implements = [
                                   "org.elixir_lang.psi.HeredocLine"
                                 ]
                                 methods = [
                                   getBody
                                   quote
                                 ]
                               }
// literals can have escape sequences for escaped terminator
literalCharListHeredocLineBody ::= (CHAR_LIST_FRAGMENT | sigilHeredocEscapeSequence)*
                                   { implements = "org.elixir_lang.psi.Body" }

literalRegexHeredoc ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                        literalRegexHeredocLine*
                        heredocPrefix REGEX_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.RegexFragmented"
                            "org.elixir_lang.psi.LiteralSigilHeredoc"
                          ]
                          pin = REGEX_HEREDOC_PROMOTER
                        }
// EOL is optional because when last line EOL is escaped (See https://github.com/KronicDeth/intellij-elixir/issues/1843)
literalRegexHeredocLine ::= heredocLinePrefix literalRegexHeredocLineBody heredocLineEnd
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
// literals can have escape sequences for escaped terminator
literalRegexHeredocLineBody ::= (REGEX_FRAGMENT | sigilHeredocEscapeSequence)*
                                { implements = "org.elixir_lang.psi.Body" }

literalSigilHeredoc ::= TILDE LITERAL_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                        literalSigilHeredocLine*
                        heredocPrefix SIGIL_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.SigilFragmented"
                            "org.elixir_lang.psi.LiteralSigilHeredoc"
                          ]
                          pin = SIGIL_HEREDOC_PROMOTER
                        }
literalSigilHeredocLine ::= heredocLinePrefix literalSigilHeredocLineBody heredocLineEnd
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
// literals can have escape sequences for escaped terminator
literalSigilHeredocLineBody ::= (SIGIL_FRAGMENT | sigilHeredocEscapeSequence)*
                                { implements = "org.elixir_lang.psi.Body" }

literalStringSigilHeredoc ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                              literalStringHeredocLine*
                              heredocPrefix STRING_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                              {
                                implements = [
                                  "org.elixir_lang.psi.StringFragmented"
                                  "org.elixir_lang.psi.LiteralSigilHeredoc"
                                ]
                                pin = STRING_SIGIL_HEREDOC_PROMOTER
                              }
literalStringHeredocLine ::= heredocLinePrefix literalStringHeredocLineBody heredocLineEnd
                             {
                               implements = [
                                 "org.elixir_lang.psi.HeredocLine"
                               ]
                               methods = [
                                 getBody
                                 quote
                               ]
                             }
// literals can have escape sequences for escaped terminator
literalStringHeredocLineBody ::= (STRING_FRAGMENT | sigilHeredocEscapeSequence)*
                                 { implements = "org.elixir_lang.psi.Body" }

literalWordsHeredoc ::= TILDE LITERAL_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                        literalWordsHeredocLine*
                        heredocPrefix WORDS_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.WordsFragmented"
                            "org.elixir_lang.psi.LiteralSigilHeredoc"
                          ]
                          pin = WORDS_HEREDOC_PROMOTER
                        }
// EOL is optional because when last line EOL is escaped (See https://github.com/KronicDeth/intellij-elixir/issues/1843)
literalWordsHeredocLine ::= heredocLinePrefix literalWordsHeredocLineBody heredocLineEnd
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
// literals can have escape sequences for escaped terminator
literalWordsHeredocLineBody ::= (WORDS_FRAGMENT | sigilHeredocEscapeSequence)*
                                { implements = "org.elixir_lang.psi.Body" }

/*
 *
 *
 * Lines (as opposed to Heredocs)
 *
 *
 */

/*
 *
 * Quote Lines
 *
 */


charListLine ::= CHAR_LIST_PROMOTER charListLineBody CHAR_LIST_TERMINATOR
                 {
                   implements = [
                     "org.elixir_lang.psi.Atomable"
                     "org.elixir_lang.psi.InterpolatedCharList"
                     "org.elixir_lang.psi.Line"
                     "org.elixir_lang.psi.Quotable"
                   ]
                   pin = CHAR_LIST_PROMOTER
                 }

charListLineBody ::= (interpolation | CHAR_LIST_FRAGMENT | lineEscapeSequence)*
                      { implements =  "org.elixir_lang.psi.Body" }

stringLine ::= STRING_PROMOTER stringLineBody STRING_TERMINATOR
               {
                 implements = [
                   "org.elixir_lang.psi.Atomable"
                   "org.elixir_lang.psi.InterpolatedString"
                   "org.elixir_lang.psi.Line"
                   "org.elixir_lang.psi.Quotable"
                 ]
                 pin = STRING_PROMOTER
               }

stringLineBody ::= (interpolation | STRING_FRAGMENT | lineEscapeSequence)*
                   { implements = "org.elixir_lang.psi.Body" }

/*
 *
 * Sigil Lines
 *
 */

/*
 * Interpolated Sigil Lines
 */

interpolatedCharListSigilLine ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER interpolatedCharListSigilLineBody CHAR_LIST_SIGIL_TERMINATOR sigilModifiers
                                  {
                                    implements = [
                                      "org.elixir_lang.psi.CharListFragmented"
                                      "org.elixir_lang.psi.InterpolatedSigilLine"
                                    ]
                                    pin = CHAR_LIST_SIGIL_PROMOTER
                                  }
interpolatedCharListSigilLineBody ::= (interpolation | CHAR_LIST_FRAGMENT | sigilLineEscapeSequence)*
                                      { implements = "org.elixir_lang.psi.Body" }

interpolatedRegexLine ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_PROMOTER interpolatedRegexLineBody REGEX_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.RegexFragmented"
                              "org.elixir_lang.psi.InterpolatedSigilLine"
                            ]
                            pin = REGEX_PROMOTER
                          }
interpolatedRegexLineBody ::= (interpolation | REGEX_FRAGMENT | sigilLineEscapeSequence)*
                              { implements = "org.elixir_lang.psi.Body" }

interpolatedSigilLine ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_PROMOTER interpolatedSigilLineBody SIGIL_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.SigilFragmented"
                              "org.elixir_lang.psi.InterpolatedSigilLine"
                            ]
                            pin = SIGIL_PROMOTER
                          }
interpolatedSigilLineBody ::= (interpolation | SIGIL_FRAGMENT | sigilLineEscapeSequence)*
                              { implements = "org.elixir_lang.psi.Body" }

interpolatedStringSigilLine ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER interpolatedStringSigilLineBody STRING_SIGIL_TERMINATOR sigilModifiers
                                {
                                  implements = [
                                    "org.elixir_lang.psi.StringFragmented"
                                    "org.elixir_lang.psi.InterpolatedSigilLine"
                                  ]
                                  pin = STRING_SIGIL_PROMOTER
                                }
interpolatedStringSigilLineBody ::= (interpolation | STRING_FRAGMENT | sigilLineEscapeSequence)*
                                    { implements = "org.elixir_lang.psi.Body" }

interpolatedWordsLine ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_PROMOTER interpolatedWordsLineBody WORDS_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.WordsFragmented"
                              "org.elixir_lang.psi.InterpolatedSigilLine"
                            ]
                            pin = WORDS_PROMOTER
                          }
interpolatedWordsLineBody ::= (interpolation | WORDS_FRAGMENT | sigilLineEscapeSequence)*
                              { implements = "org.elixir_lang.psi.Body" }

/*
 * Literal Sigils
 */

literalCharListSigilLine ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER literalCharListSigilLineBody CHAR_LIST_SIGIL_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.CharListFragmented"
                                 "org.elixir_lang.psi.LiteralSigilLine"
                               ]
                               pin = CHAR_LIST_SIGIL_PROMOTER
                             }
literalCharListSigilLineBody ::= (CHAR_LIST_FRAGMENT | sigilLineEscapeSequence)*
                                 { implements = "org.elixir_lang.psi.Body" }

literalRegexLine ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_PROMOTER literalRegexLineBody REGEX_TERMINATOR sigilModifiers
                     {
                       implements = [
                         "org.elixir_lang.psi.RegexFragmented"
                         "org.elixir_lang.psi.LiteralSigilLine"
                       ]
                       pin = REGEX_PROMOTER
                     }
literalRegexLineBody ::= (REGEX_FRAGMENT | sigilLineEscapeSequence)*
                         { implements = "org.elixir_lang.psi.Body" }

literalSigilLine ::= TILDE LITERAL_SIGIL_NAME SIGIL_PROMOTER literalSigilLineBody SIGIL_TERMINATOR sigilModifiers
                     {
                       implements = [
                         "org.elixir_lang.psi.LiteralSigilLine"
                         "org.elixir_lang.psi.SigilFragmented"
                       ]
                       pin = SIGIL_PROMOTER
                     }
literalSigilLineBody ::= (SIGIL_FRAGMENT | sigilLineEscapeSequence)*
                         { implements = "org.elixir_lang.psi.Body" }

literalStringSigilLine ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER literalStringSigilLineBody STRING_SIGIL_TERMINATOR sigilModifiers
                           {
                             implements = [
                               "org.elixir_lang.psi.StringFragmented"
                               "org.elixir_lang.psi.LiteralSigilLine"
                             ]
                             pin = STRING_SIGIL_PROMOTER
                           }
literalStringSigilLineBody ::= (STRING_FRAGMENT | sigilLineEscapeSequence)*
                               { implements = "org.elixir_lang.psi.Body" }

literalWordsLine ::=  TILDE LITERAL_WORDS_SIGIL_NAME WORDS_PROMOTER literalWordsLineBody WORDS_TERMINATOR sigilModifiers
                      {
                        implements = [
                          "org.elixir_lang.psi.WordsFragmented"
                          "org.elixir_lang.psi.LiteralSigilLine"
                        ]
                        pin = WORDS_PROMOTER
                      }
literalWordsLineBody ::= (WORDS_FRAGMENT | sigilLineEscapeSequence)*
                         { implements = "org.elixir_lang.psi.Body" }

/*
 *
 *
 * Matched Expressions - ordered by outer-most (lowest precedence) to inner-most (highest precedence)
 *
 * See ELIXIR_BNF_DESIGN.md for exanplanation of the naming and nesting pattern used in the matchedExpression rules.
 *
 *
 */

matchedExpression ::= matchedInMatchOperation |
                      /* noParenthesesKeywords needs to be first as matchedExpression will match due to the error
                         handling built into the Pratt parser. */
                      matchedWhenNoParenthesesKeywordsOperation |
                      matchedWhenOperation |
                      matchedTypeOperation |
                      matchedPipeOperation |
                      matchedCaptureNonNumericOperation |
                      matchedMatchOperation |
                      matchedOrOperation |
                      matchedAndOperation |
                      matchedComparisonOperation |
                      matchedRelationalOperation |
                      matchedArrowOperation |
                      matchedInOperation |
                      matchedNotInOperation |
                      matchedThreeOperation |
                      matchedTwoOperation |
                      matchedAdditionOperation |
                      matchedMultiplicationOperation |
                      matchedPowerOperation |
                      matchedUnaryOperation |
                      matchedDotCall |
                      // NoParentheses before matchedBracketOperation because brackets only make sense after parentheses.
                      matchedQualifiedNoParenthesesCall |
                      matchedAtUnqualifiedNoParenthesesCall |
                      matchedUnqualifiedNoParenthesesCall |
                      matchedAtNumericBracketOperation |
                      matchedBracketOperation |
                      matchedQualifiedAlias |
                      matchedQualifiedMultipleAliases |
                      matchedQualifiedBracketOperation |
                      matchedQualifiedParenthesesCall |
                      matchedQualifiedNoArgumentsCall |
                      matchedAtUnqualifiedBracketOperation |
                      matchedAtOperation | // after matchedQualified because @ binds only before `.`
                      matchedUnqualifiedParenthesesCall |
                      matchedUnqualifiedBracketOperation |
                      matchedUnqualifiedNoArgumentsCall |
                      matchedAccessExpression

/*
 * Capture Non-Numeric Operation - non-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L50
 */

private nonNumeric ::= !numeric
capturePrefixOperator ::= CAPTURE_OPERATOR
                          {
                            implements = "org.elixir_lang.psi.Operator"
                            methods = [
                              operatorTokenSet
                              quote
                            ]
                            name = "&"
                          }
matchedCaptureNonNumericOperation ::= capturePrefixOperator nonNumeric matchedExpression

/*
 * In Match Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L51
 */

inMatchInfixOperator ::= IN_MATCH_OPERATOR
                         {
                           implements = "org.elixir_lang.psi.Operator"
                           methods = [
                                         operatorTokenSet
                                         quote
                                         ]
                           name = "<-, \\\\"
                         }
// implements and methods defined by "infix operations" section above
matchedInMatchOperation ::= matchedExpression inMatchInfixOperator matchedExpression

/*
 * When Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L52
 */

whenInfixOperator ::= WHEN_OPERATOR
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "when"
                      }
/* noParenthesesKeywords needs to be in a separate operation so that only matchedWhenNoParenthesesKeywordsOperation is a
   POSTFIX operation and matchedWhenOperation can remain a BINARY operation.  With
   `(noParenthesesKeywords | matchedExpression)` as the right operand, matchdWhenExpression was a POSTFIX operator,
   which caused the precedence for matchedInMatchOperand and matchedWhenOperation to be wrong as demonstrated in
   49ffef5a33ca1102213821efb4e2140f97622ca1 by
   org.elixir_lang.parser_definition.MatchedINMatchOperationParsingTestCase.testMatchedWhenOperation. */
matchedWhenNoParenthesesKeywordsOperation ::= matchedExpression whenInfixOperator noParenthesesKeywords
                                              { elementType = matchedWhenOperation rightAssociative = true }
// implements and methods defined by "infix operations" section above
matchedWhenOperation ::= matchedExpression whenInfixOperator matchedExpression
                         { rightAssociative = true }

/*
 * Type Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L53
 */

typeInfixOperator ::= TYPE_OPERATOR
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "::"
                      }
// implements and methods defined by "infix operations" section above
matchedTypeOperation ::= matchedExpression typeInfixOperator matchedExpression
                         { rightAssociative = true }

/*
 * Pipe Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L54
 */

pipeInfixOperator ::= PIPE_OPERATOR
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "|"
                      }
// implements and methods defined by "infix operations" section above
matchedPipeOperation ::= matchedExpression pipeInfixOperator matchedExpression
                         { rightAssociative = true }

/*
 * Match Operation - right-associative
 *
 * @see see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L56
 */

matchInfixOperator ::= MATCH_OPERATOR
                       {
                         implements = "org.elixir_lang.psi.Operator"
                         methods = [
                           operatorTokenSet
                           quote
                         ]
                         name = "="
                       }
// implements and methods defined by "infix operations" section above
matchedMatchOperation ::= matchedExpression matchInfixOperator matchedExpression
                          { rightAssociative = true }

/*
 * Or Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L57
 */

orInfixOperator ::= OR_SYMBOL_OPERATOR | OR_WORD_OPERATOR
                    {
                      implements = "org.elixir_lang.psi.Operator"
                      methods = [
                        operatorTokenSet
                        quote
                      ]
                      name = "||, |||, or"
                    }
// implements and methods defined by "infix operations" section above
matchedOrOperation ::= matchedExpression orInfixOperator matchedExpression

/*
 * And Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L58
 */
andInfixOperator ::= AND_SYMBOL_OPERATOR | AND_WORD_OPERATOR
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "&&, &&&, and"
                     }
// implements and methods defined by "infix operations" section above
matchedAndOperation ::= matchedExpression andInfixOperator matchedExpression

/*
 * Comparison Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L59
 */

comparisonInfixOperator ::= COMPARISON_OPERATOR
                            {
                              implements = "org.elixir_lang.psi.Operator"
                              methods = [
                                operatorTokenSet
                                quote
                              ]
                              name = "!=, ==, =~, !==, ==="
                            }
// implements and methods defined by "infix operations" section above
matchedComparisonOperation ::= matchedExpression comparisonInfixOperator matchedExpression

/*
 * Relational Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L60
 */

relationalInfixOperator ::= RELATIONAL_OPERATOR
                            {
                              implements = "org.elixir_lang.psi.Operator"
                              methods = [
                                operatorTokenSet
                                quote
                              ]
                              name = "<, >, <=, >="
                            }
// implements and methods defined by "infix operations" section above
matchedRelationalOperation ::= matchedExpression relationalInfixOperator matchedExpression

/*
 * Arrow Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L61
 */

arrowInfixOperator ::= ARROW_OPERATOR
                       {
                         implements = "org.elixir_lang.psi.Operator"
                         methods = [
                           operatorTokenSet
                           quote
                         ]
                         name = "<~, |>, ~>, <<<, <<~, <|>, <~>, >>>, ~>>"
                       }
// implements and methods defined by "infix operations" section above
matchedArrowOperation ::= matchedExpression arrowInfixOperator matchedExpression

/*
 * In Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L62
 */

inInfixOperator ::= IN_OPERATOR
                    {
                      implements = "org.elixir_lang.psi.Operator"
                      methods = [
                        operatorTokenSet
                        quote
                      ]
                      name = "in"
                    }
// implements defined by "in operations" section above
// methods defined by "infix operations" section above
matchedInOperation ::= matchedExpression inInfixOperator matchedExpression

notInfixOperator ::= NOT_OPERATOR
                     {
                       implements = "org.elixir_lang.psi.Operator"
                         methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "not"
                     }
matchedNotInOperation ::= matchedExpression notInfixOperator inInfixOperator matchedExpression

/*
 * Three Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/3487d00ddb5e90c7cf0e65d03717903b9b27eafd/lib/elixir/src/elixir_parser.yrl#L67
 */
threeInfixOperator ::= THREE_OPERATOR
                       {
                         implements = "org.elixir_lang.psi.Operator"
                         methods = [
                           operatorTokenSet
                           quote
                         ]
                         name = "^^^"
                       }
// implements and methods defined by "infix operations" section above
matchedThreeOperation ::= matchedExpression threeInfixOperator matchedExpression

/*
 * Two Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L63
 */

twoInfixOperator ::= RANGE_OPERATOR | TWO_OPERATOR
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "++, --, .., <>"
                     }
// implements and methods defined by "infix operations" section above
matchedTwoOperation ::= matchedExpression twoInfixOperator matchedExpression
                        { rightAssociative = true }

/*
 * Addition Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L64
 *
 */

/* Unlike other binary operation, additionOperations cannot begin with EOLs: if there are EOLs, then the +/- is
   interpreted as unaryOperation. */
additionInfixOperator ::= ADDITION_OPERATOR | SUBTRACTION_OPERATOR
                          {
                            implements = "org.elixir_lang.psi.Operator"
                            methods = [
                              operatorTokenSet
                              quote
                            ]
                            name = "+, -"
                          }
// implements and methods defined by "infix operations" section above
matchedAdditionOperation ::= matchedExpression additionInfixOperator matchedExpression

/*
 * Multiplication Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L65
 *
 */

multiplicationInfixOperator ::= DIVISION_OPERATOR | MULTIPLICATION_OPERATOR
                                {
                                  implements = "org.elixir_lang.psi.Operator"
                                  methods = [
                                    operatorTokenSet
                                    quote
                                  ]
                                  name = "*, /"
                                }
// implements and methods defined by "infix operations" section above
matchedMultiplicationOperation ::= matchedExpression multiplicationInfixOperator matchedExpression

/*
 * Power Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/f689fa8b59ba82fb6dbe94fa1b05076284affbe2/lib/elixir/src/elixir_parser.yrl#L81
 */

powerInfixOperator ::= POWER_OPERATOR
                       {
                         implements = "org.elixir_lang.psi.Operator"
                         methods = [
                           operatorTokenSet
                           quote
                         ]
                         name = "**"
                       }
// implements and methods defined by "infix operations" section above
matchedPowerOperation ::= matchedExpression powerInfixOperator matchedExpression

unaryPrefixOperator ::= (NEGATE_OPERATOR | NUMBER_OR_BADARITH_OPERATOR | UNARY_OPERATOR) eolStar |
                        NOT_OPERATOR !IN_OPERATOR
                        {
                          implements = "org.elixir_lang.psi.Operator"
                          methods = [
                            operatorTokenSet
                            quote
                          ]
                          name = "+, -, !, ^, not, ~~~"
                        }

/*
 * Unary Non-Numeric Operation - non-associative (Elixir < 1.5.0)
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L67
 *
 */

/*
 * Unary Operation - non-associative (Elixir >= 1.5.0)
 */

matchedUnaryOperation ::= unaryPrefixOperator matchedExpression

/*
 * Dot Operations
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L561-L565
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L567-L572
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L574-L578
 */

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L69)
dotInfixOperator ::= DOT_OPERATOR
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       name = "."
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                     }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L71
// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L121
relativeIdentifier ::= IDENTIFIER_TOKEN |
                       AFTER |
                       AND_SYMBOL_OPERATOR |
                       AND_WORD_OPERATOR |
                       ARROW_OPERATOR |
                       // NOT ASSOCIATION_OPERATOR
                       AT_OPERATOR |
                       // NOT BIT_STRING_OPERATOR because it is a special form
                       CAPTURE_OPERATOR |
                       CATCH |
                       COMPARISON_OPERATOR |
                       DO |
                       DIVISION_OPERATOR |
                       PLUS_OPERATOR |
                       ELSE |
                       END |
                       IN_MATCH_OPERATOR |
                       IN_OPERATOR |
                       // NOT MAP_OPERATOR because it is a special form
                       MATCH_OPERATOR |
                       MINUS_OPERATOR |
                       MULTIPLICATION_OPERATOR |
                       OR_SYMBOL_OPERATOR |
                       OR_WORD_OPERATOR |
                       PIPE_OPERATOR |
                       POWER_OPERATOR |
                       RANGE_OPERATOR |
                       RELATIONAL_OPERATOR |
                       RESCUE |
                       STAB_OPERATOR |
                       STRUCT_OPERATOR |
                       THREE_OPERATOR |
                       // NOT TUPLE_OPERATOR because it is a special form
                       TWO_OPERATOR |
                       UNARY_OPERATOR |
                       WHEN_OPERATOR |
                       atomKeyword |
                       charListLine |
                       stringLine
                       { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

// @see https://github.com/elixir-lang/elixir/blob/master/lib/elixir/src/elixir_parser.yrl#L481-L482
private parenthesesPositionalArguments ::= containerArgumentsBase

// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L484-L488
parenthesesArguments ::= OPENING_PARENTHESIS
                         (
                          unqualifiedNoParenthesesManyArgumentsCall | // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L485
                          keywords | // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L486
                          parenthesesPositionalArguments (infixComma keywords)?)? // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L487-L488
                         CLOSING_PARENTHESIS
                         {
                           implements = [
                             "org.elixir_lang.psi.Arguments"
                             "org.elixir_lang.psi.QuotableArguments"
                           ]
                           methods = [
                             arguments
                             quoteArguments
                           ]
                         }

// call_args_no_parens_one
noParenthesesOneArgument ::= noParenthesesKeywords | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L417
                             unqualifiedNoParenthesesManyArgumentsCall | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L419
                             /* This should NOT be in matchedExpression as it's not in matched_expr, but in no_parens_expr,
                                but having a rule that starts with matchedExpression is only legal in a rule that extends
                                matchedExpression.

                                @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L124-L125 */
                             noParenthesesManyArgumentsStrict |
                             /* MUST be after noParenthesesManyArgumentsStrict so that matchedExpression's inbuilt error handling doesn't match with error.

                                NOTE this is used in both unmatchedExpression and matchedExpression.  Using
                                matchedExpression here ensures the `do` block is only consumed by the left-most
                                unmatchedExpression call and not any of the middle matchedExpression calls.

                                @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L418
                                @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L609-L610 */
                             matchedExpression
                             {
                               implements = [
                                 "org.elixir_lang.psi.Arguments"
                                 "org.elixir_lang.psi.MaybeModuleName"
                                 "org.elixir_lang.psi.QuotableArguments"
                               ]
                               methods = [
                                 arguments
                                 isModuleName
                                 processDeclarations
                                 quoteArguments
                               ]
                             }

matchedParenthesesArguments ::= CALL parenthesesArguments parenthesesArguments? // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L254-255

/*
 * Dot (Anonymous function) Call Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L403
 */

matchedDotCall ::= matchedExpression dotInfixOperator parenthesesArguments parenthesesArguments?
                   {
                     implements = [
                       "org.elixir_lang.psi.DotCall<org.elixir_lang.psi.stub.MatchedDotCall>"
                       "org.elixir_lang.psi.MatchedCall"
                     ]
                     mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedDotCall>"
                     stubClass = "org.elixir_lang.psi.stub.MatchedDotCall"
                   }

/*
 * Qualified No Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L191-L194
 */

matchedQualifiedNoParenthesesCall ::= matchedExpression dotInfixOperator relativeIdentifier noParenthesesOneArgument
                                      {
                                        implements = [
                                          "org.elixir_lang.psi.MatchedCall"
                                          "org.elixir_lang.psi.QualifiedNoParenthesesCall<org.elixir_lang.psi.stub.MatchedQualifiedNoParenthesesCall>"
                                        ]
                                        mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedQualifiedNoParenthesesCall>"
                                        stubClass = "org.elixir_lang.psi.stub.MatchedQualifiedNoParenthesesCall"
                                      }

/*
 * At Operation on Unqualified No Parentheses CALL
 *
 * Needed because matchedAtOperation must be after * matchedQualified* and matchedBracketOperation, but
 * matchedUnqualifiedNoParenthesesCall needs to be an operand of At so that the entire call is an operand instead of
 * just the variable.
 */

matchedAtUnqualifiedNoParenthesesCall ::= atIdentifier noParenthesesOneArgument
                                          {
                                            implements = [
                                              "org.elixir_lang.psi.AtUnqualifiedNoParenthesesCall<org.elixir_lang.psi.stub.MatchedAtUnqualifiedNoParenthesesCall>"
                                              "org.elixir_lang.psi.MatchedCall"
                                            ]
                                            mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedAtUnqualifiedNoParenthesesCall>"
                                            stubClass = "org.elixir_lang.psi.stub.MatchedAtUnqualifiedNoParenthesesCall"
                                          }

/*
 * Unqualified No Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L191-L194
 */

matchedUnqualifiedNoParenthesesCall ::= identifier noParenthesesOneArgument
                                        {
                                          implements = [
                                            "org.elixir_lang.psi.MatchedCall"
                                            "org.elixir_lang.psi.UnqualifiedNoParenthesesCall<org.elixir_lang.psi.stub.MatchedUnqualifiedNoParenthesesCall>"
                                          ]
                                          methods = [
                                            canonicalName
                                            canonicalNameSet
                                            exportedArity
                                            exportedName
                                            functionName
                                            functionNameElement
                                            getDoBlock
                                            hasDoBlockOrKeyword
                                            isExported
                                            getName
                                            getNameIdentifier
                                            getPresentation
                                            getReference
                                            getStub
                                            getUseScope
                                            isCalling
                                            isCallingMacro
                                            moduleName
                                            primaryArguments
                                            primaryArity
                                            processDeclarations
                                            implementedProtocolName
                                            quote
                                            resolvedFinalArity
                                            resolvedFinalArityInterval
                                            resolvedModuleName
                                            resolvedPrimaryArity
                                            resolvedSecondaryArity
                                            secondaryArguments
                                            secondaryArity
                                            setName
                                          ]
                                          mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedUnqualifiedNoParenthesesCall>"
                                          stubClass = "org.elixir_lang.psi.stub.MatchedUnqualifiedNoParenthesesCall"
                                        }

/*
 * Bracket Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L238
 */

bracketArguments ::= OPENING_BRACKET
                     (
                      keywords |
                      containerExpression infixCommaMaybe
                     )
                     CLOSING_BRACKET
                     { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

matchedBracketOperation ::= matchedExpression bracketArguments
                            { implements = "org.elixir_lang.psi.BracketOperation" methods = [quote] }

/*
 * Qualified Alias
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L388
 */

matchedQualifiedAlias ::= matchedExpression dotInfixOperator alias
                          {
                            implements = [
                              "org.elixir_lang.psi.NamedElement"
                              "org.elixir_lang.psi.QualifiedAlias"
                            ]
                            methods = [
                              fullyQualifiedName
                              getName
                              getNameIdentifier
                              getPresentation
                              getReference
                              isModuleName
                              processDeclarations
                              quote
                              setName
                            ]
                          }

/*
 * Qualified Multiple Alias
 *
 * See https://github.com/elixir-lang/elixir/pull/3666
 */
matchedQualifiedMultipleAliases ::= matchedExpression dotInfixOperator multipleAliases

// same rules as tuple, but quoting is different, so separate rule.
multipleAliases ::= OPENING_CURLY
                    containerArgumentsMaybe
                    CLOSING_CURLY
                    {
                      implements = "org.elixir_lang.psi.Quotable"
                      methods = [
                        processDeclarations
                        quote
                      ]
                    }


/*
 * Qualified Identifier Bracket Operation
 */

matchedQualifiedBracketOperation ::= matchedExpression dotInfixOperator relativeIdentifier CALL bracketArguments

/*
 * Qualified Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L229-L230
 */

matchedQualifiedParenthesesCall ::= matchedExpression dotInfixOperator relativeIdentifier matchedParenthesesArguments
                                    {
                                      implements = [
                                        "org.elixir_lang.psi.MatchedCall"
                                        "org.elixir_lang.psi.QualifiedParenthesesCall<org.elixir_lang.psi.stub.MatchedQualifiedParenthesesCall>"
                                      ]
                                      mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedQualifiedParenthesesCall>"
                                      stubClass = "org.elixir_lang.psi.stub.MatchedQualifiedParenthesesCall"
                                    }

/*
 * Qualified Call with No Arguments - neither parenthes nor no parentheses
 */

matchedQualifiedNoArgumentsCall ::= matchedExpression dotInfixOperator relativeIdentifier !CALL
                                    {
                                      implements = [
                                        "org.elixir_lang.psi.MatchedCall"
                                        "org.elixir_lang.psi.QualifiedNoArgumentsCall<org.elixir_lang.psi.stub.MatchedQualifiedNoArgumentsCall>"
                                      ]
                                      mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedQualifiedNoArgumentsCall>"
                                      stubClass = "org.elixir_lang.psi.stub.MatchedQualifiedNoArgumentsCall"
                                    }

/*
 * At Unqualified Bracket Operation
 *
 * Needed so that At consumes Unqualified identifier, but brackets consume both of them.
 */

matchedAtUnqualifiedBracketOperation ::= atPrefixOperator IDENTIFIER_TOKEN CALL bracketArguments
                                         { implements = "org.elixir_lang.psi.AtUnqualifiedBracketOperation" methods = [quote] }

/*
 * At Numeric Bracket Operation (Elixir >= 1.5.0)
 *
 * Needed so that At consumes numeric, but brackets consume both of them.
 */

matchedAtNumericBracketOperation ::= atPrefixOperator numeric bracketArguments
                                     { implements = "org.elixir_lang.psi.AtNumericBracketOperation" methods = [quote] }

/*
 * Unqualified Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L229-L230
 */

matchedUnqualifiedParenthesesCall ::= identifier matchedParenthesesArguments
                                      {
                                        implements = [
                                          "org.elixir_lang.psi.MatchedCall"
                                          "org.elixir_lang.psi.UnqualifiedParenthesesCall<org.elixir_lang.psi.stub.MatchedUnqualifiedParenthesesCall>"
                                        ]
                                        mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedUnqualifiedParenthesesCall>"
                                        stubClass = "org.elixir_lang.psi.stub.MatchedUnqualifiedParenthesesCall"
                                      }

atPrefixOperator ::= AT_OPERATOR
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "@"
                     }

/*
 * At Operation - non-associative (Elixir >= 1.5.0)
 */

matchedAtOperation ::= atPrefixOperator matchedExpression

/*
 * Unqualified Bracket Operation
 */

matchedUnqualifiedBracketOperation ::= identifier CALL bracketArguments
                                       {
                                         implements = "org.elixir_lang.psi.UnqualifiedBracketOperation"
                                         methods = [quote]
                                       }


/*
 * Unqualified No Arguments Call
 */

matchedUnqualifiedNoArgumentsCall ::= identifier notKeywordPairColon
                                      {
                                        implements = [
                                          "org.elixir_lang.psi.MatchedCall"
                                          "org.elixir_lang.psi.UnqualifiedNoArgumentsCall<org.elixir_lang.psi.stub.MatchedUnqualifiedNoArgumentsCall>"
                                        ]
                                        mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedUnqualifiedNoArgumentsCall>"
                                        stubClass = "org.elixir_lang.psi.stub.MatchedUnqualifiedNoArgumentsCall"
                                      }


matchedAccessExpression ::= accessExpression
                            { elementType = accessExpression }

/*
 * Access expression
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L200-L223
 *
 */

captureNumericOperation ::= capturePrefixOperator numeric

/*
 *
 * Map
 *
 */

/*
 * https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L430-L430
 * shows that '%{}' is injected by the Elixir native tokenizer when '%{' is encountered.  Since Elixir.flex can't inject
 * text, this parser is matching MAP_OPERATOR as just '%' as mapArguments contains the '{'.
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L521-L522
 */
mapPrefixOperator ::= STRUCT_OPERATOR
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "%"
                      }

private associationInfixOperator ::= ASSOCIATION_OPERATOR

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L505
containerAssociationOperation ::= containerExpression associationInfixOperator containerExpression
                                  { implements = "org.elixir_lang.psi.AssociationOperation" methods = [quote] }

left maxDotCall ::= dotInfixOperator parenthesesArguments parenthesesArguments?
                    { elementType = matchedDotCall }

left maxQualifiedAlias ::= dotInfixOperator alias
                           { elementType = matchedQualifiedAlias }

left maxQualifiedParenthesesCall ::= dotInfixOperator relativeIdentifier matchedParenthesesArguments
                                     { elementType = matchedQualifiedParenthesesCall }

left maxQualifiedNoArgumentsCall ::= dotInfixOperator relativeIdentifier !CALL
                                     { elementType = matchedQualifiedNoArgumentsCall }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L226-L231
private maxExpression ::= /* matchedBracketOperation because it is first rule after matchedDotCallOperation that will
                             take a `.`. */
                          matchedBracketOperation maxDotCall |
                          /* matchedQualifiedBracketOperation because it is in the Pratt-parsing table for
                             matchedExpression will match matchedQualifiedBracketOperation or anything after it in
                             matchedExpression.  matchedQualifiedBracketOperation is used because it is the next rule
                             after matchedQualifiedAliasOperation. maxQualifiedAlias needs to be `left` and `+` to
                             emulate the POSTFIX behavior for matchedQualifiedAliasOperation.

                             matchedQualifiedAliasOperation cannot be used because the Pratt-parsing table will allow
                             matchedQualifiedAliasOperation to match it or any lower rule. */
                          matchedQualifiedBracketOperation maxQualifiedAlias+ | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L231
                          /* matchedQualifiedNoArgumentsCall because it is first rule after
                            matchedQualifiedParenthesesCall */
                          matchedQualifiedNoArgumentsCall maxQualifiedParenthesesCall | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L231
                          /* matchedAtUnqualifiedBracketOperation and all rules thrugh accessExpression are necessary
                             because all those rules are ATOM or PREFIX so they won't also match lower rules */
                          (
                           matchedAtUnqualifiedBracketOperation |
                           matchedAtNumericBracketOperation |
                           matchedAtOperation |
                           matchedUnqualifiedParenthesesCall |
                           matchedUnqualifiedBracketOperation |
                           variable |
                           accessExpression
                          ) maxQualifiedNoArgumentsCall | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L499
                          matchedUnqualifiedParenthesesCall | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L231
                          variable | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L499
                          atom | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L226-L228
                          alias // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L231

/*
 * Map Expression
 */

atMaxExpression ::= atPrefixOperator maxExpression
                    { elementType = matchedAtOperation }

/* Anything that can hold a map.
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L498-L500
 */
private mapExpression ::= maxExpression | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L498-L499
                          atMaxExpression // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L500

private associationsExpression ::= containerAssociationOperation | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L505
                                   mapExpression // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L506
associationsBase ::= associationsExpression (infixComma associationsExpression)*
                     { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
associations ::= associationsBase infixCommaMaybe
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 * Arguments at tail of mapUpdateArguments and mapConstructionArguments
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L524-L526
 */
private mapTailArguments ::= // Must be before associations so identifiers as keyword keys match before maxExpression in associations
                             keywords | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L524
                             associationsBase infixComma keywords | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L526
                             associations // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L525

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L530-L533
mapUpdateArguments ::= matchedMatchOperation pipeInfixOperator mapTailArguments
                       { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

mapConstructionArguments ::= mapTailArguments
                             {
                               implements = "org.elixir_lang.psi.QuotableArguments"
                               methods = [
                                 arguments
                                 quoteArguments
                               ]
                             }

mapArguments ::= OPENING_CURLY
                 (
                  // Must be before mapConstructionArguments, so that PIPE_OPERATOR is used for updates and not matchedExpression.
                  mapUpdateArguments |
                  mapConstructionArguments
                 )?
                 CLOSING_CURLY
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }


mapOperation ::= mapPrefixOperator mapArguments
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

structOperation ::= mapPrefixOperator mapExpression eolStar mapArguments
                    { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

private map ::= mapOperation |
                structOperation

/*
 * Stab Operation
 */

noParenthesesArguments ::= noParenthesesOneArgument |
                           noParenthesesManyArguments
                           { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L276-L277
stabNoParenthesesSignature ::= noParenthesesArguments
                               { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 * `fn (unquote_splicing([1,2,3])) -> end` is valid, but not obvious from elixir_parser.yrl that appears to only allow
 * keywords or many arguments.
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L278-L281
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L430-L432
 */
stabParenthesesSignature ::= parenthesesArguments (whenInfixOperator expression)?
                             {
                               implements = [
                                 "org.elixir_lang.psi.Quotable"
                                 "org.elixir_lang.psi.operation.When"
                               ]
                               methods = [
                                 getNameIdentifier
                                 leftOperand
                                 operator
                                 quote
                                 rightOperand
                               ]
                             }

stabInfixOperator ::= STAB_OPERATOR
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "->"
                      }

/*
 * stabParenthesesSignature must be at same level as stabInfixOperator so that stabParenthesesSignature does not match
 * beginning of stabNoParenthesesSignature that begins with a parentheticalStab, `(one) <op> two ->`.
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L283-L284
 *    for optionalness
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L687-L702
 *    for grouping stab followed by expression into stab, so it is equivalent to expr_list (expressionList)
 */
private stabOperationPrefix ::= stabParenthesesSignature stabInfixOperator |
                                stabNoParenthesesSignature stabInfixOperator
private stabBodyExpression ::= EEX_CLOSING eex EEX_OPENING |
                               expression !(infixComma | stabInfixOperator)
private stabBodyExpressionSeparator ::= EEX_EMPTY_MARKER | endOfExpression
private stabBodyExpressionSeparatorMaybe ::= stabBodyExpressionSeparator?
stabBody ::= stabBodyExpression (stabBodyExpressionSeparator stabBodyExpression)*
             {
               implements = "org.elixir_lang.psi.Quotable"
               methods = [
                 processDeclarations
                 quote
               ]
             }

noArgumentStabOperation ::= stabInfixOperator stabBody?
                            { elementType = stabOperation }
stabOperation ::= stabOperationPrefix stabBody?
                  {
                    implements = "org.elixir_lang.psi.Quotable"
                    methods = [
                      leftOperand
                      operator
                      processDeclarations
                      quote
                      rightOperand
                    ]
                  }

private stabOperations ::= noArgumentStabOperation |
                           stabOperation (stabBodyExpressionSeparator stabOperation)*

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L268-L269
stab ::= stabOperations | stabBody
         { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L205
anonymousFunction ::= FN endOfExpressionMaybe
                      // -> is required, so use stabOperations directly and not stab as would be used used in `doBlock`
                      stab stabBodyExpressionSeparatorMaybe
                      END
                      {
                        implements = [
                          "com.intellij.psi.NavigatablePsiElement"
                          "org.elixir_lang.psi.Quotable"
                        ]
                        methods = [
                          quote
                        ]
                      }

private semicolonMaybe ::= SEMICOLON?
// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L206-L210
parentheticalStab ::= OPENING_PARENTHESIS
                      (semicolonMaybe stab semicolonMaybe | SEMICOLON)
                      CLOSING_PARENTHESIS
                      { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 * Tuple
 */

tuple ::= OPENING_CURLY
          containerArgumentsMaybe
          CLOSING_CURLY
          { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 * Bit String
 */

bitString ::= OPENING_BIT
              containerArgumentsMaybe
              CLOSING_BIT
              { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

accessExpression ::= captureNumericOperation |
                     anonymousFunction |
                     parentheticalStab |
                     numeric |
                     list |
                     map |
                     tuple |
                     bitString |
                     stringLine notKeywordPairColon |
                     stringHeredoc |
                     charListLine notKeywordPairColon |
                     charListHeredoc |
                     interpolatedCharListSigilLine |
                     interpolatedCharListSigilHeredoc |
                     interpolatedRegexHeredoc |
                     interpolatedSigilHeredoc |
                     interpolatedStringSigilHeredoc |
                     interpolatedWordsHeredoc |
                     interpolatedWordsLine |
                     interpolatedRegexLine |
                     interpolatedSigilLine |
                     interpolatedStringSigilLine |
                     literalCharListSigilLine |
                     literalCharListSigilHeredoc |
                     literalRegexHeredoc |
                     literalSigilHeredoc |
                     literalStringSigilHeredoc |
                     literalWordsHeredoc |
                     literalRegexLine |
                     literalSigilLine |
                     literalStringSigilLine |
                     literalWordsLine |
                     atomKeyword |
                     atom |
                     alias
                     {
                       implements = [
                         "org.elixir_lang.psi.MaybeModuleName"
                         "org.elixir_lang.psi.Quotable"
                       ]
                       methods = [
                         isModuleName
                         quote
                       ]
                     }

// See eexFile in EEx.bnf
eex ::= (EEX_DATA | EEX_ESCAPED_OPENING | eexTag)+
        {
          methods = [
            processDeclarations
          ]
        }

// CANNOT be `{ pin = 1 }` because an `EEX_OPENING` is also used in `doBlock`
eexTag ::= EEX_OPENING (eexCommentBody | eexElixirBody) EEX_CLOSING
           {
             methods = [
               processDeclarations
             ]
           }

private eexCommentBody ::= EEX_COMMENT_MARKER EEX_COMMENT?
                           { pin = 1 }
private eexFunctionalMarker ::= EEX_EQUALS_MARKER | EEX_FORWARD_SLASH_MARKER | EEX_PIPE_MARKER
private eexFunctionalElixirBody ::= eexFunctionalMarker elixirFile
                                    { pin = 1 }
// DO NOT { pin = 1 ] because EEX_EMPTY_MARKER can occur before `END` and `blockItem`
private eexProceduralElixirBody ::= EEX_EMPTY_MARKER elixirFile
private eexElixirBody ::= eexFunctionalElixirBody | eexProceduralElixirBody

// keywords that map to atoms
atomKeyword ::= FALSE | NIL | TRUE
                { implements = "org.elixir_lang.psi.Quotable" methods = [quote] name = "false, nil, true" }

alias ::= ALIAS_TOKEN notKeywordPairColon
          {
            implements = [
              "org.elixir_lang.psi.NamedElement"
              "org.elixir_lang.psi.QualifiableAlias"
              "org.elixir_lang.psi.Quotable"
            ]
            methods = [
              fullyQualifiedName
              getName
              getNameIdentifier
              getPresentation
              getReference
              isModuleName
              processDeclarations
              quote
              setName
            ]
          }

/*
 *
 *
 * Unmatched Expressions
 *
 *
 */

/*
 * Capture Non-Numeric Operation - non-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L50
 */

unmatchedCaptureNonNumericOperation ::= capturePrefixOperator nonNumeric unmatchedExpression

/*
 * In Match Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L51
 */

// implements and methods defined by "infix operations" section above
unmatchedInMatchOperation ::= unmatchedExpression inMatchInfixOperator unmatchedExpression

/*
 * When Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L52
 */

/* noParenthesesKeywords needs to be in a separate operation so that only unmatchedWhenNoParenthesesKeywordsOperation is a
   POSTFIX operation and unmatchedWhenOperation can remain a BINARY operation.  With
   `(noParenthesesKeywords | matchedExpression)` as the right operand, matchdWhenExpression was a POSTFIX operator,
   which caused the precedence for matchedInMatchOperand and matchedWhenOperation to be wrong as demonstrated in
   49ffef5a33ca1102213821efb4e2140f97622ca1 by
   org.elixir_lang.parser_definition.MatchedINMatchOperationParsingTestCase.testMatchedWhenOperation. */
unmatchedWhenNoParenthesesKeywordsOperation ::= unmatchedExpression whenInfixOperator noParenthesesKeywords
                                                { elementType = unmatchedWhenOperation rightAssociative = true }
// implements and methods defined by "infix operations" section above
unmatchedWhenOperation ::= unmatchedExpression whenInfixOperator unmatchedExpression
                           { rightAssociative = true }

/*
 * Type Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L53
 */

// implements and methods defined by "infix operations" section above
unmatchedTypeOperation ::= unmatchedExpression typeInfixOperator unmatchedExpression
                           { rightAssociative = true }

/*
 * Pipe Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L54
 */

// implements and methods defined by "infix operations" section above
unmatchedPipeOperation ::= unmatchedExpression pipeInfixOperator unmatchedExpression
                           { rightAssociative = true }

/*
 * Match Operation - right-associative
 *
 * @see see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L56
 */


// implements and methods defined by "infix operations" section above
unmatchedMatchOperation ::= unmatchedExpression matchInfixOperator unmatchedExpression
                            { rightAssociative = true }

/*
 * Or Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L57
 */

// implements and methods defined by "infix operations" section above
unmatchedOrOperation ::= unmatchedExpression orInfixOperator unmatchedExpression

/*
 * And Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L58
 */

// implements and methods defined by "infix operations" section above
unmatchedAndOperation ::= unmatchedExpression andInfixOperator unmatchedExpression

/*
 * Comparison Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L59
 */

// implements and methods defined by "infix operations" section above
unmatchedComparisonOperation ::= unmatchedExpression comparisonInfixOperator unmatchedExpression

/*
 * Relational Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L60
 */

// implements and methods defined by "infix operations" section above
unmatchedRelationalOperation ::= unmatchedExpression relationalInfixOperator unmatchedExpression

/*
 * Arrow Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L61
 */

// implements and methods defined by "infix operations" section above
unmatchedArrowOperation ::= unmatchedExpression arrowInfixOperator unmatchedExpression

/*
 * In Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L62
 */

// implements defined by "in operations" section above
// methods defined by "infix operations" section above
unmatchedInOperation ::= unmatchedExpression inInfixOperator unmatchedExpression

unmatchedNotInOperation ::= unmatchedExpression notInfixOperator inInfixOperator unmatchedExpression

/*
 * Three Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/3487d00ddb5e90c7cf0e65d03717903b9b27eafd/lib/elixir/src/elixir_parser.yrl#L67
 */
// implements and methods defined by "infix operations" section above
unmatchedThreeOperation ::= unmatchedExpression threeInfixOperator unmatchedExpression

/*
 * Two Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L63
 */

// implements and methods defined by "infix operations" section above
unmatchedTwoOperation ::= unmatchedExpression twoInfixOperator unmatchedExpression
                          { rightAssociative = true }

/*
 * Addition Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L64
 *
 */

// implements and methods defined by "infix operations" section above
unmatchedAdditionOperation ::= unmatchedExpression additionInfixOperator unmatchedExpression

/*
 * Multiplication Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L65
 *
 */

// implements and methods defined by "infix operations" section above
unmatchedMultiplicationOperation ::= unmatchedExpression multiplicationInfixOperator unmatchedExpression

/*
 * Power Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/f689fa8b59ba82fb6dbe94fa1b05076284affbe2/lib/elixir/src/elixir_parser.yrl#L81
 *
 */

// implements and methods defined by "infix operations" section above
unmatchedPowerOperation ::= unmatchedExpression powerInfixOperator unmatchedExpression


/*
 * Unary Operation - non-associative (Elixir >= 1.5.0)
 */

unmatchedUnaryOperation ::= unaryPrefixOperator unmatchedExpression

/*
 * Dot Operations
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L561-L565
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L567-L572
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L574-L578
 */

private doBlockMaybe ::= doBlock?

/*
 * Dot (Anonymous function) Call Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L403
 */

unmatchedDotCall ::= unmatchedExpression dotInfixOperator parenthesesArguments parenthesesArguments? doBlockMaybe
                     {
                       implements = "org.elixir_lang.psi.DotCall<org.elixir_lang.psi.stub.UnmatchedDotCall>"
                       mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedDotCall>"
                       stubClass = "org.elixir_lang.psi.stub.UnmatchedDotCall"
                     }

/*
 * Qualified No Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L191-L194
 */

unmatchedQualifiedNoParenthesesCall ::= unmatchedExpression dotInfixOperator relativeIdentifier noParenthesesOneArgument doBlockMaybe
                                        {
                                          implements = [
                                            "org.elixir_lang.psi.QualifiedNoParenthesesCall<org.elixir_lang.psi.stub.UnmatchedQualifiedNoParenthesesCall>"
                                          ]
                                          mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedQualifiedNoParenthesesCall>"
                                          stubClass = "org.elixir_lang.psi.stub.UnmatchedQualifiedNoParenthesesCall"
                                        }

/*
 * At Operation on Unqualified No Parentheses CALL
 *
 * Needed because matchedAtOperation must be after *matchedQualified* and *matchedBracketOperation, but
 * *matchedUnqualifiedNoParenthesesCall needs to be an operand of At so that the entire call is an operand instead of
 * just the variable.
 */

atIdentifier ::= atPrefixOperator IDENTIFIER_TOKEN
                 { methods = [getReference] }
unmatchedAtUnqualifiedNoParenthesesCall ::= atIdentifier noParenthesesOneArgument doBlockMaybe
                                            {
                                              implements = "org.elixir_lang.psi.AtUnqualifiedNoParenthesesCall<org.elixir_lang.psi.stub.UnmatchedAtUnqualifiedNoParenthesesCall>"
                                              mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedAtUnqualifiedNoParenthesesCall>"
                                              stubClass = "org.elixir_lang.psi.stub.UnmatchedAtUnqualifiedNoParenthesesCall"
                                            }

/*
 * Unqualified No Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L191-L194
 */

unmatchedUnqualifiedNoParenthesesCall ::= identifier noParenthesesOneArgument doBlockMaybe
                                          {
                                            implements = "org.elixir_lang.psi.UnqualifiedNoParenthesesCall<org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoParenthesesCall>"
                                            methods = [
                                              canonicalName
                                              canonicalNameSet
                                              exportedArity
                                              exportedName
                                              functionName
                                              functionNameElement
                                              getDoBlock
                                              hasDoBlockOrKeyword
                                              isExported
                                              getName
                                              getNameIdentifier
                                              getPresentation
                                              getReference
                                              getStub
                                              getUseScope
                                              isCalling
                                              isCallingMacro
                                              moduleName
                                              primaryArguments
                                              primaryArity
                                              processDeclarations
                                              implementedProtocolName
                                              quote
                                              resolvedFinalArity
                                              resolvedFinalArityInterval
                                              resolvedModuleName
                                              resolvedPrimaryArity
                                              resolvedSecondaryArity
                                              secondaryArguments
                                              secondaryArity
                                              setName
                                            ]
                                            mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoParenthesesCall>"
                                            stubClass="org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoParenthesesCall"
                                          }

/*
 * Bracket Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L238
 */

unmatchedBracketOperation ::= unmatchedExpression bracketArguments
                              { implements = "org.elixir_lang.psi.BracketOperation" methods = [quote] }

/*
 * Qualified Alias
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L388
 */

unmatchedQualifiedAlias ::= unmatchedExpression dotInfixOperator alias
                            {
                              implements = "org.elixir_lang.psi.QualifiedAlias"
                              methods = [
                                fullyQualifiedName
                                getName
                                getNameIdentifier
                                getPresentation
                                getReference
                                isModuleName
                                processDeclarations
                                quote
                                setName
                              ]
                            }

/*
 * Qualified Multiple Alias
 *
 * See https://github.com/elixir-lang/elixir/pull/3666
 */
unmatchedQualifiedMultipleAliases ::= unmatchedExpression dotInfixOperator multipleAliases

/*
 * Qualified Identifier Bracket Operation
 */

unmatchedQualifiedBracketOperation ::= unmatchedExpression dotInfixOperator relativeIdentifier CALL bracketArguments

/*
 * Qualified Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L229-L230
 */

unmatchedQualifiedParenthesesCall ::= unmatchedExpression dotInfixOperator relativeIdentifier matchedParenthesesArguments doBlockMaybe
                                      {
                                        implements = "org.elixir_lang.psi.QualifiedParenthesesCall<org.elixir_lang.psi.stub.UnmatchedQualifiedParenthesesCall>"
                                        mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedQualifiedParenthesesCall>"
                                        stubClass = "org.elixir_lang.psi.stub.UnmatchedQualifiedParenthesesCall"
                                      }

/*
 * Qualified Call with No Arguments - neither parenthes nor no parentheses
 */

unmatchedQualifiedNoArgumentsCall ::= unmatchedExpression dotInfixOperator relativeIdentifier !CALL doBlockMaybe
                                      {
                                        implements = [
                                          "org.elixir_lang.psi.QualifiedNoArgumentsCall<org.elixir_lang.psi.stub.UnmatchedQualifiedNoArgumentsCall>"
                                        ]
                                        mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedQualifiedNoArgumentsCall>"
                                        stubClass = "org.elixir_lang.psi.stub.UnmatchedQualifiedNoArgumentsCall"
                                      }

/*
 * At Unqualified Bracket Operation
 *
 * Needed so that At consumes Unqualified identifier, but brackets consume both of them.
 */

unmatchedAtUnqualifiedBracketOperation ::= atPrefixOperator IDENTIFIER_TOKEN CALL bracketArguments
                                           { implements = "org.elixir_lang.psi.AtUnqualifiedBracketOperation" methods = [quote] }

/*
 * At Numeric Operation (Elixir >= 1.5.0)
 *
 * Needed so that At consumes numeric, but brackets consume both of them.
 */

unmatchedAtNumericBracketOperation ::= atPrefixOperator numeric bracketArguments
                                       { implements = "org.elixir_lang.psi.AtNumericBracketOperation" methods = [quote] }


/*
 * Unqualified Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L229-L230
 */

unmatchedUnqualifiedParenthesesCall ::= identifier matchedParenthesesArguments doBlockMaybe
                                        {
                                          implements = "org.elixir_lang.psi.UnqualifiedParenthesesCall<org.elixir_lang.psi.stub.UnmatchedUnqualifiedParenthesesCall>"
                                          mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedUnqualifiedParenthesesCall>"
                                          stubClass = "org.elixir_lang.psi.stub.UnmatchedUnqualifiedParenthesesCall"
                                        }

/*
 * At Operation - non-associative (Elixir >= 1.5.0)
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L70
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L567-L572
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L574-L578
 */

unmatchedAtOperation ::= atPrefixOperator unmatchedExpression

/*
 * Unqualified Bracket Operation
 */

unmatchedUnqualifiedBracketOperation ::= identifier CALL bracketArguments
                                         {
                                           implements = "org.elixir_lang.psi.UnqualifiedBracketOperation"
                                           methods = [quote]
                                         }

/*
 * Unqualified No Arguments Call
 */

unmatchedUnqualifiedNoArgumentsCall ::= identifier notKeywordPairColon doBlockMaybe
                                        {
                                          implements = "org.elixir_lang.psi.UnqualifiedNoArgumentsCall<org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoArgumentsCall>"
                                          mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoArgumentsCall>"
                                          stubClass = "org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoArgumentsCall"
                                        }

unmatchedAccessExpression ::= accessExpression
                              { elementType = accessExpression }

/*
 *
 * Do Block
 *
 */

/*
 * Block Identifier
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L946
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L977-L981
 */
blockIdentifier ::= AFTER | CATCH | ELSE | RESCUE
                    { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L313-L314
blockItem ::= blockIdentifier endOfExpressionMaybe // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L290-L291
              (stab endOfExpressionMaybe)? // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L313
              { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L316-L317
blockList ::= blockItem+
              { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }
private eexWhitespace ::= EEX_CLOSING EEX_OPENING EEX_EMPTY_MARKER
private doStabSeparator ::= endOfExpression | eexWhitespace
private doStabSeparatorMaybe ::= doStabSeparator?
// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L272-L275
doBlock ::= DO doStabSeparatorMaybe
            stab? stabBodyExpressionSeparatorMaybe // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L273
            blockList? stabBodyExpressionSeparatorMaybe // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L274
            END
            {
              implements = "org.elixir_lang.psi.QuotableArguments"
              methods = [quoteArguments]
              pin = DO
            }


// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L143-L148
unmatchedExpression ::= unmatchedInMatchOperation |
                        /* noParenthesesKeywords needs to be first as matchedExpression will match due to the error
                         handling built into the Pratt parser. */
                        unmatchedWhenNoParenthesesKeywordsOperation |
                        unmatchedWhenOperation |
                        unmatchedTypeOperation |
                        unmatchedPipeOperation |
                        unmatchedCaptureNonNumericOperation |
                        unmatchedMatchOperation |
                        unmatchedOrOperation |
                        unmatchedAndOperation |
                        unmatchedComparisonOperation |
                        unmatchedRelationalOperation |
                        unmatchedArrowOperation |
                        unmatchedInOperation |
                        unmatchedNotInOperation |
                        unmatchedThreeOperation |
                        unmatchedTwoOperation |
                        unmatchedAdditionOperation |
                        unmatchedMultiplicationOperation |
                        unmatchedPowerOperation |
                        unmatchedUnaryOperation |
                        unmatchedDotCall |
                        // NoParentheses before unmatchedBracketOperation because brackets only make sense after parentheses.
                        unmatchedQualifiedNoParenthesesCall |
                        unmatchedAtUnqualifiedNoParenthesesCall |
                        unmatchedUnqualifiedNoParenthesesCall |
                        unmatchedAtNumericBracketOperation |
                        unmatchedBracketOperation |
                        unmatchedQualifiedAlias |
                        unmatchedQualifiedMultipleAliases |
                        unmatchedQualifiedBracketOperation |
                        unmatchedQualifiedParenthesesCall |
                        unmatchedQualifiedNoArgumentsCall |
                        unmatchedAtUnqualifiedBracketOperation |
                        unmatchedAtOperation | // after unmatchedQualified because @ binds only before `.`
                        unmatchedUnqualifiedParenthesesCall |
                        unmatchedUnqualifiedBracketOperation |
                        unmatchedUnqualifiedNoArgumentsCall |
                        unmatchedAccessExpression

/*
 *
 *
 * Whole Numbers
 *
 *
 *
 */

decimalDigits ::= INVALID_DECIMAL_DIGITS | VALID_DECIMAL_DIGITS
                  { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
decimalWholeNumber ::= decimalDigits (NUMBER_SEPARATOR? decimalDigits)*
                        {
                          implements = "org.elixir_lang.psi.WholeNumber"
                          methods = [
                            base
                            digitsList
                            quote
                          ]
                        }

/*
 *
 * Base (Non-Decimal) Whole Numbers
 *
 */

/*
 * Binary (2)
 */

binaryDigits ::= INVALID_BINARY_DIGITS | VALID_BINARY_DIGITS
                 { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
binaryWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (BINARY_WHOLE_NUMBER_BASE | OBSOLETE_BINARY_WHOLE_NUMBER_BASE) binaryDigits (NUMBER_SEPARATOR? binaryDigits)*
                     {
                       implements = "org.elixir_lang.psi.WholeNumber"
                       methods = [
                         base
                         digitsList
                         quote
                       ]
                       pin = 2
                     }

/*
 * Hexadecimal (16)
 */

hexadecimalDigits ::= INVALID_HEXADECIMAL_DIGITS | VALID_HEXADECIMAL_DIGITS
                      { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
hexadecimalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (HEXADECIMAL_WHOLE_NUMBER_BASE | OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE) hexadecimalDigits (NUMBER_SEPARATOR? hexadecimalDigits)*
                           {
                             implements = "org.elixir_lang.psi.WholeNumber"
                             methods = [
                               base
                               digitsList
                               quote
                             ]
                             pin = 2
                           }

/*
 * Octal (8)
 */

octalDigits ::= INVALID_OCTAL_DIGITS | VALID_OCTAL_DIGITS
                { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
octalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX OCTAL_WHOLE_NUMBER_BASE octalDigits (NUMBER_SEPARATOR? octalDigits)*
                     {
                       implements = "org.elixir_lang.psi.WholeNumber"
                       methods = [
                         base
                         digitsList
                         quote
                       ]
                       pin = 2
                     }

/*
 * Unknown (1-36)
 */

unknownBaseDigits ::= INVALID_UNKNOWN_BASE_DIGITS
                      { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
unknownBaseWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX UNKNOWN_WHOLE_NUMBER_BASE unknownBaseDigits+
                           {
                             implements = "org.elixir_lang.psi.WholeNumber"
                             methods = [
                               base
                               digitsList
                               quote
                             ]
                             pin=2
                           }

/*
 *
 *
 * In alphabetical order
 *
 *
 */

atom ::= COLON (ATOM_FRAGMENT | quote)
         {
           implements = [
             "com.intellij.psi.NavigatablePsiElement"
             "com.intellij.psi.PsiNamedElement"
             "org.elixir_lang.psi.Quotable"
           ]
           methods = [
             getReference
             quote
             setName
           ]
         }

private infixComma ::= COMMA eolStar
private infixCommaMaybe ::= infixComma?

charToken ::= CHAR_TOKENIZER (CHAR_LIST_FRAGMENT | lineEscapeSequence)
              { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

private containerExpression ::= emptyParentheses |
                                unmatchedExpression

decimalFloat ::= decimalFloatIntegral DECIMAL_MARK decimalFloatFractional (EXPONENT_MARK decimalFloatExponent)?
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
decimalFloatExponent ::= decimalFloatExponentSign? decimalWholeNumber
decimalFloatExponentSign ::= SIGN_OPERATOR
decimalFloatFractional ::= decimalWholeNumber
decimalFloatIntegral ::= decimalWholeNumber

/*
 *
 * Escape Sequences
 *
 */

/*
 * Shared subrules
 */

hexadecimalEscapePrefix ::= ESCAPE (HEXADECIMAL_WHOLE_NUMBER_BASE | UNICODE_ESCAPE_CHARACTER)
enclosedHexadecimalEscapeSequence ::= OPENING_CURLY VALID_HEXADECIMAL_DIGITS CLOSING_CURLY
                                      { implements = "org.elixir_lang.psi.EscapedHexadecimalDigits" methods = [codePoint] pin = 1 }
openHexadecimalEscapeSequence ::= VALID_HEXADECIMAL_DIGITS
                                  { implements = "org.elixir_lang.psi.EscapedHexadecimalDigits" methods = [codePoint] }
escapedCharacter ::= ESCAPE ESCAPED_CHARACTER_TOKEN
                     { implements = "org.elixir_lang.psi.EscapeSequence" methods = [codePoint] }
escapedEOL ::= ESCAPE EOL
               { implements = "org.elixir_lang.psi.EscapeSequence" methods = [codePoint] }
private heredocLineEnd ::= (escapedEOL | EOL)

/*
 * Quotes (charListHeredoc, charListLine, stringHeredoc, stringLine)
 */

/*
 * Does not contain `escapedEOL` as heredocs require EOL to end each line even if they are escaped by the user
 */
private heredocEscapeSequence ::= quoteHexadecimalEscapeSequence |
                                  escapedCharacter

private lineEscapeSequence ::= quoteHexadecimalEscapeSequence |
                               escapedEOL |
                               /* Must be last so that ESCAPE ('\') can be pinned in escapedCharacter without excluding
                                  ("\x") in hexadecimalEscapeSequence  */
                               escapedCharacter
quoteHexadecimalEscapeSequence ::= hexadecimalEscapePrefix (openHexadecimalEscapeSequence | enclosedHexadecimalEscapeSequence)
                                   {
                                     implements = "org.elixir_lang.psi.EscapeSequence"
                                     methods = [codePoint]
                                     pin = 1
                                   }

/*
 * Keywords
 */

keywordKey ::= AFTER |
               ALIAS_TOKEN |
               AND_SYMBOL_OPERATOR |
               AND_WORD_OPERATOR |
               ARROW_OPERATOR |
               ASSOCIATION_OPERATOR |
               ATOM_FRAGMENT |
               AT_OPERATOR |
               BIT_STRING_OPERATOR |
               CAPTURE_OPERATOR |
               CATCH |
               COMPARISON_OPERATOR |
               DO |
               DIVISION_OPERATOR |
               ELSE |
               END |
               FALSE |
               IN_MATCH_OPERATOR |
               IN_OPERATOR |
               MAP_OPERATOR |
               MATCH_OPERATOR |
               MINUS_OPERATOR |
               MULTIPLICATION_OPERATOR |
               NIL |
               NOT_OPERATOR |
               OR_SYMBOL_OPERATOR |
               OR_WORD_OPERATOR |
               PIPE_OPERATOR |
               PLUS_OPERATOR |
               POWER_OPERATOR |
               RANGE_OPERATOR |
               RESCUE |
               RELATIONAL_OPERATOR |
               SIGN_OPERATOR |
               STAB_OPERATOR |
               STRUCT_OPERATOR |
               THREE_OPERATOR |
               TRUE |
               TUPLE_OPERATOR |
               TWO_OPERATOR |
               UNARY_OPERATOR |
               WHEN_OPERATOR |
               quote
               {
                 implements = [
                   "org.elixir_lang.psi.NamedElement"
                   "org.elixir_lang.psi.Quotable"
                 ]
                 methods = [
                   getName
                   getNameIdentifier
                   getPresentation
                   quote
                   setName
                 ]
               }
// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L499
private keywordKeyColon ::= keywordKey KEYWORD_PAIR_COLON

/* @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L499 */
keywordPair ::=  keywordKeyColon containerExpression
                 {
                   implements = "org.elixir_lang.psi.QuotableKeywordPair"
                   methods = [
                     getKeywordKey
                     getKeywordValue
                     quote
                   ]
                 }
/* @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L500
   @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L502-L503 */
keywords ::= keywordPair (infixComma keywordPair)* COMMA?
             { implements = "org.elixir_lang.psi.QuotableKeywordList" methods = [quotableKeywordPairList quote] }

/*
 * Sigil
 */

private sigilLineEscapeSequence ::= sigilHexadecimalEscapeSequence |
                                    hexadecimalEscapePrefix |
                                    escapedEOL |
                                    escapedCharacter
// Does not pin so that escapePrefix can match separately as `\x` and `\u` is valid for sigils
sigilHexadecimalEscapeSequence ::= hexadecimalEscapePrefix (openHexadecimalEscapeSequence | enclosedHexadecimalEscapeSequence)
                                   {
                                     implements = "org.elixir_lang.psi.EscapeSequence"
                                     methods = [codePoint]
                                   }
private sigilHeredocEscapeSequence ::= sigilHexadecimalEscapeSequence |
                                       hexadecimalEscapePrefix |
                                       escapedCharacter

emptyParentheses ::= OPENING_PARENTHESIS CLOSING_PARENTHESIS
                     { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
interpolation ::= INTERPOLATION_START elixirFile INTERPOLATION_END

/*
 * List
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L476-L484
 */

private containerArgumentsBase ::= containerExpression (infixComma containerExpression)*
private containerArguments ::= containerArgumentsBase (infixComma keywords | infixComma)?
private containerArgumentsMaybe ::= containerArguments?

private listArguments ::= keywords |
                          containerArguments

list ::= OPENING_BRACKET
         listArguments?
         CLOSING_BRACKET
         { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/* elixir_tokenizer.erl converts CHAR_TOKEN_TOKENs to their number representation, so `number` in elixir_parser.yrl matches
   Elixir.flex's CHAR_TOKEN_TOKEN and all the different base number rules. */
private numeric ::= charToken |
                    binaryWholeNumber |
                    // decimalFloat starts with decimalWholeNumber, so decimalFloat needs to be first
                    decimalFloat |
                    decimalWholeNumber |
                    hexadecimalWholeNumber |
                    octalWholeNumber |
                    unknownBaseWholeNumber

private quote ::= (charListLine | stringLine)
